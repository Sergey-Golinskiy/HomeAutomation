#include <ESP8266WiFi.h>
#include <PubSubClient.h>
#include <ArduinoOTA.h>

const char* ssid          = "SmartGrow_AP";
const char* password      = "smartgrow_xoqO7h7o";
const char* mqtt_server   = "192.168.1.100";
const char* mqtt_user     = "sg_mqtt_user";
const char* mqtt_password = "858hBCnYAUv73fa54hSf";

WiFiClient espClient;
PubSubClient client(espClient);

#define ID_CONNECT      "myhome-Conditioner"
#define DEVICE_ID       "haier_cond"               // уникальный ID для Discovery
#define DEVICE_NAME     "Haier Conditioner"
#define LED             12
#define LEN_B           37

// Индексы пакета Haier
#define B_CUR_TMP       13
#define B_CMD           17
#define B_MODE          23
#define B_FAN_SPD       25
#define B_SWING         27
#define B_LOCK_REM      28
#define B_POWER         29
#define B_FRESH         31
#define B_SET_TMP       35

int fresh, power, swing, lock_rem, cur_tmp, set_tmp, fan_spd, Mode;
long prev = 0;
byte inCheck = 0;
byte qstn[]      = {255,255,10,0,0,0,0,0,1,1,77,1,90};
byte dataHaier[LEN_B];
byte onCmd[]     = {255,255,10,0,0,0,0,0,1,1,77,2,91};
byte offCmd[]    = {255,255,10,0,0,0,0,0,1,1,77,3,92};
byte lockCmd[]   = {255,255,10,0,0,0,0,0,1,3,0,0,14};

byte getCRC(const byte *buf, size_t sz) {
  byte crc = 0;
  for (int i = 2; i < sz; i++) crc += buf[i];
  return crc;
}
void SendData(const byte *buf, size_t sz) {
  Serial.write(buf, sz - 1);
  Serial.write(getCRC(buf, sz - 1));
}

void setup_wifi() {
  pinMode(LED, OUTPUT);
  digitalWrite(LED, LOW);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    digitalWrite(LED, !digitalRead(LED));
  }
  digitalWrite(LED, HIGH);
}

void reconnect() {
  digitalWrite(LED, !digitalRead(LED));
  while (!client.connected()) {
    if (client.connect(ID_CONNECT, mqtt_user, mqtt_password)) {
      client.publish("myhome/Conditioner/connection","true",true);
      client.publish("myhome/Conditioner/RAW","",true);
      client.subscribe("myhome/Conditioner/#");
      digitalWrite(LED, HIGH);
    } else {
      delay(5000);
    }
  }
}

inline unsigned char toHex(char ch) {
  return ((ch >= 'A') ? (ch - 'A' + 0xA) : (ch - '0')) & 0x0F;
}

void InsertData(byte d[], size_t sz) {
  set_tmp  = d[B_SET_TMP] + 16;
  cur_tmp  = d[B_CUR_TMP];
  Mode     = d[B_MODE];
  fan_spd  = d[B_FAN_SPD];
  swing    = d[B_SWING];
  lock_rem = d[B_LOCK_REM];
  power    = d[B_POWER];
  fresh    = d[B_FRESH];

  client.publish("myhome/Conditioner/Fresh",      fresh    ? "on":"off",   true);
  client.publish("myhome/Conditioner/Lock_Remote",lock_rem ? "true":"false",true);

  // Power
  if (power==1||power==0x11)   client.publish("myhome/Conditioner/Power","on",true);
  else if (power==0||power==0x10) client.publish("myhome/Conditioner/Power","off",true);
  else if (power==9)            client.publish("myhome/Conditioner/Power","quiet",true);
  client.publish("myhome/Conditioner/Compressor",
                 (power&0x10)?"on":"off",true);

  // Swing
  const char* swings[] = {"off","ud","lr","all"};
  client.publish("myhome/Conditioner/Swing", swings[swing], true);

  // Fan_Speed
  const char* fans[] = {"max","mid","min","auto"};
  client.publish("myhome/Conditioner/Fan_Speed", fans[fan_spd], true);

  // Set / Current Temp
  char buf[6];
  snprintf(buf,sizeof(buf),"%d",set_tmp);
  client.publish("myhome/Conditioner/Set_Temp", buf, true);
  snprintf(buf,sizeof(buf),"%d",cur_tmp);
  client.publish("myhome/Conditioner/Current_Temp", buf, true);

  // Mode
  const char* modes[] = {"smart","cool","heat","vent","dry"};
  client.publish("myhome/Conditioner/Mode", modes[Mode], true);

  // RAW
  String raw;
  for (int i=0;i<LEN_B;i++){
    if (d[i]<16) raw += '0';
    raw += String(d[i],HEX);
  }
  raw.toUpperCase();
  client.publish("myhome/Conditioner/RAW", raw.c_str(), true);
}

void callback(char* topic, byte* payload, unsigned int length) {
  payload[length] = '\0';
  String t(topic), p((char*)payload);

  if      (t=="myhome/Conditioner/Set_Temp")   { int v=p.toInt()-16; if(v>=0&&v<=30) dataHaier[B_SET_TMP]=v; }
  else if (t=="myhome/Conditioner/Mode")      {
    if(p=="smart") dataHaier[B_MODE]=0;
    if(p=="cool")  dataHaier[B_MODE]=1;
    if(p=="heat")  dataHaier[B_MODE]=2;
    if(p=="vent")  dataHaier[B_MODE]=3;
    if(p=="dry")   dataHaier[B_MODE]=4;
  }
  else if (t=="myhome/Conditioner/Fan_Speed") {
    if(p=="max")  dataHaier[B_FAN_SPD]=0;
    if(p=="mid")  dataHaier[B_FAN_SPD]=1;
    if(p=="min")  dataHaier[B_FAN_SPD]=2;
    if(p=="auto") dataHaier[B_FAN_SPD]=3;
  }
  else if (t=="myhome/Conditioner/Swing")     {
    if(p=="off") dataHaier[B_SWING]=0;
    if(p=="ud")  dataHaier[B_SWING]=1;
    if(p=="lr")  dataHaier[B_SWING]=2;
    if(p=="all") dataHaier[B_SWING]=3;
  }
  else if (t=="myhome/Conditioner/Lock_Remote"){
    dataHaier[B_LOCK_REM] = (p=="true")?0x80:0x00;
  }
  else if (t=="myhome/Conditioner/Power")     {
    if(p=="on")  { SendData(onCmd,sizeof(onCmd));  return; }
    if(p=="off") { SendData(offCmd,sizeof(offCmd)); return; }
    if(p=="quiet") dataHaier[B_POWER]=9;
  }
  else if (t=="myhome/Conditioner/RAW")       {
    char buf[75];
    p.toCharArray(buf,75);
    for(int i=0;i<37;i++){
      dataHaier[i] = (toHex(buf[i*2])<<4)|toHex(buf[i*2+1]);
    }
    Serial.write(dataHaier, LEN_B);
    client.publish("myhome/Conditioner/RAW", buf, true);
    return;
  }

  // Собираем и шлём общий пакет
  dataHaier[B_CMD]=0;
  dataHaier[9]    =1;
  dataHaier[10]   =77;
  dataHaier[11]   =95;
  SendData(dataHaier, LEN_B);
}

void publishDiscovery() {
  // Device payload
  String dev = "{\"identifiers\":[\"" DEVICE_ID "\"],"
               "\"name\":\"" DEVICE_NAME "\","
               "\"manufacturer\":\"Haier\",\"model\":\"AC\"}";

  // Climate discovery
  String cfg = "homeassistant/climate/" DEVICE_ID "/config";
  String pl = "{"
    "\"name\":\"" DEVICE_NAME "\","
    "\"unique_id\":\"" DEVICE_ID "_climate\","
    "\"mode_state_topic\":\"myhome/Conditioner/Mode\","
    "\"mode_command_topic\":\"myhome/Conditioner/Mode\","
    "\"temperature_state_topic\":\"myhome/Conditioner/Current_Temp\","
    "\"temperature_command_topic\":\"myhome/Conditioner/Set_Temp\","
    "\"current_temperature_topic\":\"myhome/Conditioner/Current_Temp\","
    "\"min_temp\":16,\"max_temp\":30,\"temp_step\":1,"
    "\"modes\":[\"smart\",\"cool\",\"heat\",\"vent\",\"dry\"],"
    "\"fan_modes\":[\"max\",\"mid\",\"min\",\"auto\"],"
    "\"swing_modes\":[\"off\",\"ud\",\"lr\",\"all\"],"
    "\"fan_mode_state_topic\":\"myhome/Conditioner/Fan_Speed\","
    "\"fan_mode_command_topic\":\"myhome/Conditioner/Fan_Speed\","
    "\"swing_mode_state_topic\":\"myhome/Conditioner/Swing\","
    "\"swing_mode_command_topic\":\"myhome/Conditioner/Swing\","
    "\"availability_topic\":\"homeassistant/climate/" DEVICE_ID "/availability\","
    "\"payload_available\":\"online\",\"payload_not_available\":\"offline\","
    "\"device\":" + dev + ",\"retain\":true"
  "}";

  client.publish(cfg.c_str(), pl.c_str(), true);

  // Switch: Fresh
  cfg = "homeassistant/switch/" DEVICE_ID "_fresh/config";
  pl = "{"
    "\"name\":\"" DEVICE_NAME " Fresh\","
    "\"unique_id\":\"" DEVICE_ID "_fresh\","
    "\"command_topic\":\"myhome/Conditioner/Fresh\","
    "\"state_topic\":\"myhome/Conditioner/Fresh\","
    "\"payload_on\":\"on\",\"payload_off\":\"off\","
    "\"availability_topic\":\"homeassistant/climate/" DEVICE_ID "/availability\","
    "\"device\":" + dev + ",\"retain\":true"
  "}";
  client.publish(cfg.c_str(), pl.c_str(), true);

  // Switch: Lock_Remote
  cfg = "homeassistant/switch/" DEVICE_ID "_lock/config";
  pl = "{"
    "\"name\":\"" DEVICE_NAME " Lock Remote\","
    "\"unique_id\":\"" DEVICE_ID "_lock\","
    "\"command_topic\":\"myhome/Conditioner/Lock_Remote\","
    "\"state_topic\":\"myhome/Conditioner/Lock_Remote\","
    "\"payload_on\":\"true\",\"payload_off\":\"false\","
    "\"availability_topic\":\"homeassistant/climate/" DEVICE_ID "/availability\","
    "\"device\":" + dev + ",\"retain\":true"
  "}";
  client.publish(cfg.c_str(), pl.c_str(), true);

  // Availability state
  client.publish("homeassistant/climate/" DEVICE_ID "/availability","online",true);
}

void setup() {
  setup_wifi();
  client.setServer(mqtt_server, 1883);
  client.setCallback(callback);

  reconnect();
  publishDiscovery();

  ArduinoOTA.setHostname("Haier");
  ArduinoOTA.begin();
}

void loop() {
  ArduinoOTA.handle();

  if (Serial.available() >= LEN_B) {
    Serial.readBytes(dataHaier, LEN_B);
    while (Serial.available()) { Serial.read(); }
    if (dataHaier[36] != inCheck) {
      inCheck = dataHaier[36];
      InsertData(dataHaier, LEN_B);
    }
  }

  if (!client.connected()) reconnect();
  client.loop();

  if (millis() - prev > 5000) {
    prev = millis();
    SendData(qstn, sizeof(qstn));
  }
}
